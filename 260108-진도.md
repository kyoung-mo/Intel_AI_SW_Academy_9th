### 3.상태 머신 및 점프 테이블(Jump Table)
복잡하고 긴 `if-else` 문이나 `switch-case`문을 대체하여 성능을 높이고 코드를 간결하게 만듭니다. 함수 포인터 배열을 사용합니다.
- 사용 이유 : O(1)의 속도로 조건에 맞는 함수를 실행할 수 있다.
- 통신 프로토콜 파서나 명령어 처리기에서 많이 쓰인다.

예시 코드(명령어 처리기)
```c
#include <stdio.h>

void cmd_start() { printf("System Starting...\n"); }
void cmd_stop()  { printf("System Stopping...\n"); }
void cmd_reset() { printf("System Reset...\n"); }

int main() {
    // 함수 포인터 배열 (Look-up Table)
    void (*cmd_actions[])(void) = {cmd_start, cmd_stop, cmd_reset};
    
    int opcode = 1; // 0: start, 1: stop, 2: reset
    
    // switch문 없이 배열 인덱스로 바로 실행
    if(opcode >= 0 && opcode <= 2) {
        cmd_actions[opcode](); 
    }
    return 0;
}
```

---

### 4. 동적 라이브러리 로딩(Plugin Architecture)
프로그램 실행 중에 외부 라이브러리(.so 파일)를 로드하고 그 안의 함수를 실행할 때 사용합니다.

- **관련 함수:** `dlopen`, `dlsym`, `dlclose`
- **활용:** 플러그인 시스템을 만들 때 필수적입니다. 메인 프로그램은 컴파일 시점에 플러그인의 존재를 몰라도 됩니다.

**예시 코드 (개념):**

plugin.c
```c
#include <dlfcn.h>

int main() {
    void *handle = dlopen("./libplugin.so", RTLD_LAZY);
    
    // 심볼(함수 이름)로 함수 포인터 획득
    void (*plugin_func)() = dlsym(handle, "do_something");
    
    if (plugin_func) {
        plugin_func(); // 동적으로 불러온 함수 실행
    }
    
    dlclose(handle);
    return 0;
}
```

---

### 5. 인터럽트 및 시그널 핸들러(System Level)
리눅스 시스템 프로그래밍 레벨에서, 특정 하드웨어 인터럽트나 OS 시그널이 발생했을 때 제어권을 넘겨받을 함수를 등록합니다.
- 대표 사례 : `signal()` 함수나 `sigaction` 구조체
- 주의점 : 핸들러 함수 내부에서는 비동기적으로 안전한(Async-signal-safe) 함수만 사용해야 하는 제약이 있습니다.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 시그널이 발생하면 호출될 함수 포인터 타겟
void handle_sigint(int sig) {
    printf("\nCaught signal %d (Ctrl+C)\n", sig);
}

int main() {
    // 함수 포인터를 등록
    signal(SIGINT, handle_sigint); 
    
    while(1) {
        printf("Running... (Press Ctrl+C)\n");
        sleep(1);
    }
    return 0;
}
```

| **사용 사례** | **핵심 목적** | **대표 키워드/함수** |
| --- | --- | --- |
| **콜백** | 실행 흐름의 제어권 위임 | `qsort`, `pthread_create` |
| **다형성** | 구조체로 객체지향 흉내내기 | `file_operations` (커널), 드라이버 |
| **점프 테이블** | `switch`문 대체, 성능 최적화 | 배열(`[]`), 상태 머신 |
| **동적 로딩** | 런타임 플러그인 확장 | `dlopen`, `dlsym` |
| **핸들러** | 비동기 이벤트 처리 | `signal`, ISR |


---

Chap 17. 구조체

- 배열은 같은 형태의 데이터를 묶어서 처리
- 다른 형태의 데이터? -> 구조체 이용
- 구조체 선언을 해야 사용 가능

```c
struct student{
  int num;
  double grade;
};
```

구조체 선언 시 메모리에 지정 안된다?
전역변수는? 선언 했을때 메모리에 잡힘

- 구조체는 선언 하고 실제 코드에서 사용을 해야 메모리에 지정된다.
- `struct student s1;` : 새로 만든 구조체를 변수로 선언할 때는 struct 예약어와 구조체 이름을 함께 하나의 자료형 이름으로 사용
- typedef를 이용해서 앞에 struct 없이 사용?

- 구조체 변수를 선언하면 비로서 저장 공간이 할당된다.

<img width="300" height="126" alt="image" src="https://github.com/user-attachments/assets/ed966da4-cc4f-4cad-8ccf-d8144d21bba7" />

- 선언된 구조체 변수는 그 안에 여러개의 맴버를 가지므로 특정 맴버를 골라서 사용해야한다.
- 이때 별도의 맴버 접근 연산자 `.` 가 필요.

<img width="217" height="138" alt="image" src="https://github.com/user-attachments/assets/fd8cc0a4-42a9-4c6c-a322-c65fd7fd6178" />

### 구조체 변수의 크기
- 모든 시스템은 데이터를 빠르게 읽고 쓰기 위해 일정한 크기 단위로 메모리에 접근
  - 한번에 메모리에서 읽음
  - 중간에 1바이트 들어가면 걔 때문에 메모리가 어긋날 수 있다.
  - 이때 실행 효율을 위해 패딩 바이트를 넣어 바이트 정렬을 한다. (= 바이트 얼라이먼트)
 
<img width="675" height="445" alt="image" src="https://github.com/user-attachments/assets/8c28d24b-4ab0-4de9-a5b4-db2ea114cdb8" />

- `pack(1)`로 하면 컴파일러에 패딩 바이트를 넣지 않도록 지시할 수 있다.
- 구조체 선언 전에 적어주건, include 다음에 적어준다.
- `#pragma pack(1)` -> (숫자)에 따라 pack의 개수가 만들어진다.
- `#pragma once` : 헤더파일을 카피해서 넣는다? 똑같은 헤더파일을 계속 넣으면 오류의 위험. 한 곳이 아닌 여러 곳에서 읽을 때 중복되는 부분들은 `include` 시키지 않는다.

- **맴버의 순서에 따라 구조체의 크기가 달라질 수 있다.**

- 기본 자료형 외에 배열, 포인터, 다른 구조체를 맴버로 사용 가능함.

```c
 #define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct profile         // 신상명세 구조체 선언
{
	char name[20];     // 이름을 저장할 배열 멤버
	int age;           // 나이
	double height;     // 키
	char* intro;       // 자기소개를 위한 포인터
};

int main(void)
{
	struct profile yuni;                 // profile 구조체 변수 선언

	strcpy(yuni.name, "서하윤");         // name 배열 멤버에 이름 복사
	yuni.age = 17;                       // age 멤버에 나이 저장
	yuni.height = 164.5;                 // height 멤버에 키 저장

	yuni.intro = (char*)malloc(80);      // 자기소개를 저장할 공간 동적 할당
	printf("자기소개 : ");
	gets(yuni.intro);                    // 할당한 공간에 자기소개 입력

	printf("이름 : %s\n", yuni.name);    // 각 멤버의 데이터 출력
	printf("나이 : %d\n", yuni.age);
	printf("키 : %.1lf\n", yuni.height);
	printf("자기소개 : %s\n", yuni.intro);
	free(yuni.intro);                    // 동적 할당 영역 반환

	return 0;
}
```

- 각 맴버 접근 연산자 ( `.` ) 를 통해 접근
- `strcpy([문자열(?)],[문자열])`를 통해 문자열 복사해서 넣어줌
- `malloc()` 으로 동적 할당 시 힙 영역 메모리 관리를 위해 사용 후 꼭 `free()` 사용

### 구조체의 맴버로 다른 구조체 사용

```c
#include <stdio.h>

struct profile            // 신상명세 구조체 선언
{
	int age;              // 나이
	double height;        // 키
};

struct student
{
	struct profile pf;    // profile 구조체를 멤버로 사용
	int id;               // 학번을 저장할 멤버
	double grade;         // 학점을 저장할 멤버
};

int main(void)
{
	struct student yuni;      // student 구조체 변수 선언

	yuni.pf.age = 17;         // pf 멤버의 age 멤버에 나이 저장
	yuni.pf.height = 164.5;   // pf 멤버의 height 멤버에 키 저장
	yuni.id = 315;
	yuni.grade = 4.3;

	printf("나이 : %d\n", yuni.pf.age);       // pf 멤버의 age 멤버 출력
	printf("키 : %.1lf\n", yuni.pf.height);   // pf 멤버의 height 멤버 출력
	printf("학번 : %d\n", yuni.id);           // id 멤버 출력
	printf("학점 : %.1lf\n", yuni.grade);     // grade 멤버 출력

	return 0;
}
```

- `struct student` 안에 `struct profile pf;`로 `profile` 구조체를 맴버로 사용할 수 있다.
- `yuni.pf.age=17;` 과 같이 이용
- profile 구조체의 맴버를 사용하려면 맴버 접근 연산자 `.` 을 2번 사용해야한다.

<img width="313" height="208" alt="image" src="https://github.com/user-attachments/assets/dc884a80-4459-46da-ba17-9734a3ecf4dd" />


### 구조체 포인터와 `->` 연산자 (arrow, 화살표)

- 구조체 변수는 그 안에 여러 개의 변수를 맴버로 가질 수 있으나, 그 자신은 단지 하나의 변수이다.
- 구조체 변수에 주소 연산자를 사용하면 특정 맴버의 주소가 아니라 구조체 변수 전체의 주소를 구한다.
- 그 값을 저장할 때는 구조체 포인터를 사용한다.

```c
#include <stdio.h>

struct score		// 구조체 선언
{
	int kor;		// 국어 점수를 저장할 멤버
	int eng;		// 영어 점수
	int math;		// 수학 점수
};

int main(void)
{
	struct score yuni = { 90, 80, 70 };   // 구조체 변수 선언과 초기화
	struct score* ps = &yuni;             // 구조체 포인터에 주소 저장

	printf("국어 : %d\n", (*ps).kor);     // 구조체 포인터로 멤버 접근
	printf("영어 : %d\n", ps->eng);       // -> 연산자 사용
	printf("수학 : %d\n", ps->math);

	return 0;
}
```

- `(*ps).kor` 와 `ps->eng` 는 문법적으로 같은 말

### 구조체 배열을 처리하는 함수

```c
#include <stdio.h>

struct address        // 주소록을 만들 구조체 선언
{
	char name[20];    // 이름을 저장할 멤버
	int age;          // 나이를 저장할 멤버
	char tel[20];     // 전화번호를 저장할 멤버
	char addr[80];    // 주소를 저장할 멤버
};

void print_list(struct address* lp);

int main(void)
{
	struct address list[5] = {        // 요소가 5개인 구조체 배열 선언
		{"홍길동", 23, "111 - 1111", "울릉도 독도"},
		{"이순신", 35, "222 - 2222", "서울 건천동"},
		{"장보고", 19, "333 - 3333", "완도 청해진"},
		{"유관순", 15, "444 - 4444", "충남 천안"},
		{"안중근", 45, "555 - 5555", "황해도 해주"}
	};

	print_list(list);

	return 0;
}

void print_list(struct address* lp)   // 매개변수는 구조체 포인터
{
	int i;                            // 반복 제어 변수

	for (i = 0; i < 5; i++)           // 배열 요소의 개수 만큼 반복
	{
		printf("%10s%5d%15s%20s\n",   // 각 배열 요소의 멤버 출력
			(lp + i)->name, (lp + i)->age, (lp + i)->tel, (lp + i)->addr);
	}
}
```

- `void print_list(strict address* lp)` 를 사용할 때는 주소를 같이 넘겨줘야한다.
- `int size = sizeof(list)/sizeof(struct address);` <<-- ?? 왜 list[0]이 아닌지 질문.
- `int size = sizeof(lp)` 를 진행하면 8Byte가 나옴

### 자기 참조 구조체
- 자기 자신을 구조체로 넣는 것은 원칙적으로 안된다.
- 하지만 포인터를 이용하면 자기 자신을 참조하게 구조체를 만들 수 있다.


```c
#include <stdio.h>

struct list              // 자기 참조 구조체
{
	int num;             // 데이터를 저장하는 멤버
	struct list* next;   // 구조체 자신을 가리키는 포인터 멤버
};

int main(void)
{
	struct list a = { 10, 0 }, b = { 20, 0 }, c = { 30, 0 };  // 구조체 변수 초기화
	struct list* head = &a, * current;                        // 헤드 포인터 초기화

	a.next = &b;                        // a의 포인터 멤버가 b를 가리킴
	b.next = &c;                        // b의 포인터 멤버가 c를 가리킴

	printf("head->num : %d\n", head->num);        // head가 가리키는 a의 num 멤버 사용
	printf("head->next->num : %d\n", head->next->num);    // head로 b의 num 멤버 사용

	printf("list all : ");
	current = head;                     // 최초 current 포인터가 a를 가리킴
	while (current != NULL)             // 마지막 구조체 변수까지 출력하면 반복 종료
	{
		printf("%d  ", current->num);   // current가 가리키는 구조체 변수의 num 출력
		current = current->next;        // current가 다음 구조체 변수를 가리키도록 함
	}
	printf("\n");

	return 0;
}
```

- linked list는 100개 1000개 정도는 괜찮으나 수없이 많을때는 효율이 떨어진다(찾는데 오래 걸린다).

### 연결 리스트

<img width="528" height="169" alt="image" src="https://github.com/user-attachments/assets/a00af535-4f05-471f-8a3a-6f4ada2d2635" />

- 헤더를 알고 있으면 링크 박스에 저장된 주소를 통해 다음 노드랑 연결
- 각 노드도 다음 노드의 주소가 저장되어있음.

### 열거형(enum)
- 구조체와 비슷하게 선언하나, 연거형은 변수에 저장할 수 있는 정수 값을 기호로 정의하여 나열한다.

```c
#include <stdio.h>

enum season { SPRING, SUMMER, FALL, WINTER };  // 열거형 선언

int main(void)
{
	enum season ss;              // 열거형 변수 선언
	char* pc = NULL;             // 문자열을 저장할 포인터

	ss = SPRING;                 // 열거 멤버의 값 대입
	switch (ss)                  // 열거 멤버 판단
	{
		case 'a'SPRING:                 // 봄이면
			pc = "inline"; break;    // 인라인 문자열 선택
		case SUMMER:                 // 여름이면
			pc = "swimming"; break;  // 수영 문자열 선택
		case FALL:                   // 가을이면
			pc = "trip"; break;      // 여행 문자열 선택
		case WINTER:                 // 겨울이면
		pc = "skiing"; break;    // 스키 문자열 선택
	}
	printf("나의 레저 활동 = > %s\n", pc);     // 선택된 문자열 출력

	return 0;
}
```

- `enum season { SPRING, SUMMER, FALL, WINTER };` 와 같이 사용.
- `SPRING=10, SUMMER, FALL=20, WINTER` 인 경우에는 `SUMMER = 11` , `WINTER=21`

- typedef문으로 기본 자료형 재정의하기
- 복잡한 응용 자료형뿐만 아니라 필요에 따라 기본 자료형도 재정의해서 사용 가능.
- ` typedef unsigned int nbyte;`

- `typedef`를 쓰는 이유
- 32비트와 64비트 컴퓨터 모두 컴파일을 하고 싶다.
- 어떤 데이터 타입은 아키텍쳐에 따라 4byte, 8byte로 달라질 수 있다.
- 데이터 사이즈가 달라질수도 있으니 `typedef`를 이용해서 아키텍처에 상관없이 데이터 타입을 사용할 수 있게 한다.

---

18장은 내일 진도

## 19장

### 전처리 지시자
- 프로그램은 컴파일환경을 바꾸거나 여러 개의 모듈로 나누어 작성할 때, 이식성과 호환성을 고려해야한다.
- 컴파일 전에 컴파일 환경에 맞게 소스코드를 편집할 수 있는 기능이 필요하고, 이를 전처리지시자라고 한다.

<img width="708" height="464" alt="image" src="https://github.com/user-attachments/assets/12c69207-8a40-4776-bf14-16f1b19e804d" />

### 파일을 포함하는 `#include`
- `<>` : 컴파일러의 include 디렉터리 에서 헤더 파일 참조
- `""` : 소스 파일이 저장된 디렉터리에서 참조

- `student.h` : 사용자 정의 헤더 파일을 사용하는 프로그램

```c
// 사용자 정의 헤더 파일 – student.h
typedef struct        // student 구조체 선언
{
    int num;          // 학번
    char name[20];    // 이름
} Student;
```

- `main.c` : 사용자 정의 헤더 파일을 사용하는 프로그램

```c
// 소스 파일 – main.c
#include <stdio.h>           // 시스템 헤더 파일의 내용 복사
#include "student.h"         // 사용자 정의 헤더 파일의 내용 복사

int main(void)
{
    Student a = { 315, "홍길동" };   // 구조체 변수 선언과 초기화

    printf("학번 : %d, 이름 : %s\\n", a.num, a.name);  // 구조체 멤버 출력

    return 0;
}
```
- `include` 는 파일의 내용을 단순히 복사하여 붙여넣는 기능을 한다.

### 매크로명으로 만드는 `#define`
- 매크로명을 정의하면 복잡한 상수나 문장을 의미 있는 다너로 쓸 수 있다.

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define PI 3.14159                        // 상수를 매크로명으로 정의
#define LIMIT 100.0                       // 상수를 매크로명으로 정의
#define MSG "passed!"                     // 문자열을 매크로명으로 정의
#define ERR_PRN printf("범위를 벗어났습니다!\\n")  // 출력문을 매크로명으로 정의

int main(void)
{
    double radius, area;                  // 반지름과 면적 변수

		
    printf("반지름을 입력하세요(100 이하) : ");
    scanf("%lf", &radius);                // 반지름 입력
    area = PI * radius * radius;          // 면적 계산
    if (radius > LIMIT) ERR_PRN;            // 반지름이 100을 초과하면 오류 메시지 출력
    else printf("원의 면적 : %.2lf(%s)\\n", area, MSG);  // 면적과 메시지 출력

    return 0;
}
```

-  PI` , `LIMIT` 등은 preprosess를 거친 후 작동
-  모든 매크로 명은 전처리 과정에서 치환될 부분으로 바뀐다.
-  상수 대신해서 쓰이는 매크로를 매크로상수라고 한다.
-  에러 메시지를 소스코드에서 즉시 확인하기 힘들어진다는 단점이 있음
-  전처리 = 치환
- 요즘 권고되는 사항은 `매크로 상수` 대신 => `const 상수`

### define을 사용한 매크로 함수

```c
#include <stdio.h>

void func(void);

int main(void)
{
    printf("컴파일 날짜와 시간 : %s, %s\n\n", __DATE__, __TIME__);
    printf("파일명 : %s\n", __FILE__);
    printf("함수명 : %s\n", __FUNCTION__);
    printf("행번호 : %d\n", __LINE__);

#line 100 "macro.c"   // 행 번호를 100부터 시작, 파일명은 macro.c로 표시
    func();           // 여기부터 행 번호는 100으로 시작

    return 0;
}

void func(void)
{
    printf("\\n");
    printf("파일명 : %s\\n", __FILE__);
    printf("함수명 : %s\\n", __FUNCTION__);
    printf("행번호 : %d\\n", __LINE__);
}
```

- __~~__ : 매크로 함수?
__FILE__	: 전체 디렉터리 경로를 포함한 파일명
__FUCNTION__	: 매크로명이 사용된 함수 이름
__LINE__	: 매크로명이 사용된 행 번호
__DATE__	: 컴파일을 시작한 날짜
__TIME__	: 컴파일을 시작한 시간

### 매크로 연산자 #과 ##

- `#` : 매크로 함수의 인수를 문자열로 치환
- `##` : 두 인수를 붙여서 치환

```c
#include <stdio.h>
#define PRINT_EXPR(x) printf(#x " = %d\n", x)
#define NAME_CAT(x, y) (x ## y)

int main(void)
{
    int a1, a2;

    NAME_CAT(a, 1) = 10;     // (a1) = 10;
    NAME_CAT(a, 2) = 20;     // (a2) = 20;
    PRINT_EXPR(a1 + a2);     // printf("a1 + a2" " = %d\\n", a1 + a2);
    PRINT_EXPR(a2 - a1);     // printf("a2 - a1" " = %d\\n", a2 - a1);

    return 0;
}
```

### 조건부 컴파일 지시자
- 소스코드를 조건에 따라 선택적으로 컴파일
- 전처리 지시자를 다양한 방법으로 조합하여 사용

```c
#include <stdio.h>
#define VER 7          // 치환될 부분이 있는 매크로명 정의
#define BIT16          // 치환될 부분이 없는 매크로명 정의

int main(void)
{
    int max;

#if VER >= 6           // 매크로명 VER이 6 이상이면
    printf("버전 %d입니다.\\n", VER);    // 이 문장 컴파일
#endif                 // #if의 끝

#ifdef BIT16           // 매크로명 BIT16이 정의되어 있으면
    max = 32767;       // 이 문장 컴파일
#else                  // BIT16이 정의되어 있지 않으면
    max = 2147483647;  // 이 문장 컴파일
#endif                 // #ifdef의 끝

    printf("int형 변수의 최댓값 : %d\\n", max);   // max 출력

    return 0;
}
```

- `#if` 사용 시 마지막에 `#endif` 를 넣어줘야 함.

### pragma 지시자 -> 예전 버전과는 호환 안될 수 있음
- 컴파일러의 컴파일 방법을 세부적으로 제어할 때 사용.
    - pack : 구조체의 패딩 바이트 크기를 결정
    - warning : 경고 메세지를 관리
 
- `# pragma warning(disable:4101);`
- `# pragma once`
    - #define 을 통해 한번만 define 되게 해주는 역할

- `gcc -E animal.c > 1.txt` : preprocess만 실행한 결과 저장 가

### 분할 컴파일
- 개별적으로 코드를 작성하고 컴파일 및 에러 수정을 할 수 있어야 한다.
- 데이터 공유와 코드 재활용이 가능해야 한다. -> 수정은 용이하게, 변경은 어렵게

실습 - `분할 컴파일 실습 - 리눅스`
`.a` : 정적 라이브러리 : 소스 코드에 라이브러리 전체가 다 들어간다.
`.so` : 셰어드 오브젝트 : 실행 파일이 실행 될 때 so를 찾고 그 파일이 있으면 경로를 찾아서 로드를 한다.(실행 초기에) , 만약 파일이 없으면 실행이 안된다.

```c

```

- `include` : 헤더파일(`.h`) 저장
- `src` : 라이브러리 소스 코드(`.c`) 저장
- `lib` : 생성된 라이브러리 파일 (`.a` , `.so`) 저장
- `app` : 메인 프로그램 소스 코드 (`.c`) 저장

# 분할 컴파일 실습-리눅스

리눅스 환경에서 **분할 컴파일**, **라이브러리 생성(.a, .so)**, 그리고 **헤더와 라이브러리가 서로 다른 디렉토리에 있을 때의 빌드 과정**

---

### 1. 프로젝트 디렉토리 및 파일 준비

먼저, 실제 개발 환경처럼 폴더 구조를 만듭니다.

- `include`: 헤더 파일(`.h`) 저장
- `src`: 라이브러리 소스 코드(`.c`) 저장
- `lib`: 생성된 라이브러리 파일(`.a`, `.so`) 저장
- `app`: 메인 프로그램 소스 코드(`.c`) 저장

### 1.1 디렉토리 생성

터미널에서 다음 명령어를 입력하세요.

Bash

```c
mkdir -p my_project/{include,src,lib,app}
cd my_project
```

### 1.2 파일 작성

① 헤더 파일 (include/mymath.h)

함수의 원형(Prototype)을 선언합니다.

mymath.h

```c
// include/mymath.h
#ifndef MYMATH_H
#define MYMATH_H

int add(int a, int b);
int subtract(int a, int b);

#endif
```

② 라이브러리 소스 

실제 기능을 구현합니다.

add.c

```c
// src/add.c
#include "mymath.h"

int add(int a, int b) {
    return a + b;
  
  }

```

substract.c

```c
// src/substract.c
#include "mymath.h"

int subtract(int a, int b) {
    return a - b;
    }
```

③ 메인 프로그램 (app/main.c)

라이브러리를 사용하는 코드입니다.

main.c

```c
// app/main.c
#include <stdio.h>
#include <mymath.h> // <>를 사용합니다 (빌드 시 -I 옵션으로 경로 지정 예정)

int main() {
    int x = 10, y = 5;
    printf("Add: %d\n", add(x, y));
    printf("Subtract: %d\n", subtract(x, y));
    return 0;
}
```

---

### 2. 오브젝트 파일 생성 (공통 단계)

라이브러리를 만들기 전에 소스 코드를 기계어 코드인 오브젝트 파일(.o)로 컴파일해야 합니다.

이때 공유 라이브러리(.so) 생성을 고려하여 -fPIC (Position Independent Code) 옵션을 붙여주는 것이 좋습니다.

Bash

---

```c
# -c: 컴파일만 수행 (링크 안 함)
# -fPIC: 위치 독립적 코드 생성 (공유 라이브러리용)
# -I./include: 헤더 파일이 있는 경로 지정

gcc -c -fPIC src/add.c  -I./include -o src/add.o
gcc -c -fPIC src/substract.c -I./include -o src/substract.o
```

### 3. 정적 라이브러리 (.a) 만들기 및 사용

정적 라이브러리는 프로그램 빌드 시 코드가 실행 파일 안에 **복사**되어 들어갑니다.

### 3.1 라이브러리 생성 (`ar` 명령어)

`ar` (archiver) 명령어를 사용하여 `.o` 파일을 묶습니다. 라이브러리 이름은 반드시 `lib`로 시작해야 합니다 (예: `libmymath.a`).

Bash

```c
# r: replace (기존 파일 있으면 덮어쓰기)
# c: create (새로 생성)
# s: index 생성 (링크 속도 향상)

ar rcs lib/libmymath.a src/add.o  src/substract.o
```

### 3.2 정적 라이브러리와 링크하여 빌드하기

이제 `main.c`와 `libmymath.a`를 합쳐 실행 파일을 만듭니다.

Bash

### 3.3 실행

정적 라이브러리는 실행 파일에 포함되므로, 라이브러리 파일이 없어져도 실행됩니다.

```c

# -I: 헤더 파일 경로 (include 폴더)
# -L: 라이브러리 파일 경로 (lib 폴더)
# -l: 라이브러리 이름 (libmymath.a에서 앞의 lib와 뒤의 .a를 뗀 이름 'mymath')

gcc -o app/main_static app/main.c -I./include -L./lib -lmymath
```

Bash

```c
./app/main_static
```

---

### 4. 공유 라이브러리 (.so) 만들기 및 사용

공유 라이브러리는 실행 시점에 메모리에 로드되어 연결됩니다.

### 4.1 라이브러리 생성 (`shared` 옵션)

Bash

```c
gcc -shared -o lib/libmymath.so src/add.o src/substract.o
```

### 4.2 공유 라이브러리와 링크하여 빌드하기

명령어는 정적 라이브러리 때와 거의 같습니다. 링커는 같은 이름의 `.so`와 `.a`가 있으면 **보통 `.so`를 우선**합니다.

Bash

```c
gcc -o app/main_shared app/main.c -I./include -L./lib -lmymath
```

### 4.3 실행 (중요: `LD_LIBRARY_PATH`)

공유 라이브러리로 빌드한 실행 파일은 실행 시점에 `.so` 파일을 찾습니다. 기본 시스템 경로(`/usr/lib` 등)가 아닌 곳에 라이브러리가 있다면, **환경 변수**를 설정해줘야 합니다.

만약 그냥 실행하면 다음과 같은 에러가 납니다:

> error while loading shared libraries: libmymath.so: cannot open shared object file...
> 

**해결 방법:**

Bash

```c
# 현재 폴더의 lib 디렉토리를 라이브러리 탐색 경로에 추가
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/lib

++ 쉘에 들어올때마다 export하려면 

```c
vi ~/.bashrc

# shift-g => 맨 밑으로 갑니다.
# a => insert모드에서 다음을 추가
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/andrew/project/my_project/lib

# esc -> :wq -> enter
```

# 실행
./app/main_shared
```





































