### C 코딩 시 부족한것
- 배열이랑 너무 안 친하다는 느낌이 든다.
- 포인터도 너무 생소하다.
- 배열 + 포인터는 개념만 알겠고 실제 코드에는 적용이 힘들다.
- 구조체는 조금씩 알듯 말듯 하나 아직도 잘 모른다.

- 코드를 직접 짜는 능력
	- 코드에서 배열 초기화 정리
 	- 배열 내에 값 차례대로 넣는 알고리즘?
 	
---

### 극복 방안
- C언어 교재 1회 정독
- 배열, 포인터, 구조체 관련 예제 한 번씩 직접 따라서 손코딩 해보기(익숙해지는 용도)

---

### 궁금한 점 정리
- 런타임? 컴파일타임?
- 

---

## 복습 내용 정리

- 함수 앞에 아무것도 없다면 `extren`
- `0x7fffffffd300` -> 스택 영역? 다시 알아보기
- 스택(stack) 구조 -> 스택포인트(sp) 마지막 포인트 위치

![](https://velog.velcdn.com/images/mommers/post/281f3b6d-d28e-4e44-a455-515bf9e42bca/image.png)

### 1. 프로그램 로더
- 데이터 영역, 힙 영역 등 초기화
- 이후 `main()` 함수 호출
- 윈도우, 리눅스 교재 다름

### 2. 함수 포인터

`int (*fp) (int, int)` 
- fp를 변수같이 사용 가능.

ex) 
```c
int (*fp) (int, int)	// 함수 포인터 선언
int sum(int a, int b); 
fp=sum;		// 함수 명을 함수 포인터에 저장
```

### 3. void 포인터

```c
void* vp;
vp = &a;
printf("a : %d\n", *(int*)vp);
```

### 4. 콜백 함수(Callback Mechanism)
가장 흔한 사용 사례로, 특정 이벤트가 발생하거나 작업이 완료되었을 때 호출될 함수를 인자로 전달한다.
- 사용 이유 : 라이브러리 작성자가 사용자가 정의한 로직을 수행할 수 있도록 "구멍"을 열어두기 위함
- 대표 사례 : `qsort` (정렬), `pthread_create` (스레드 실행), `signal` (시그널 핸들링)

1. `qsort` 활용 예제_1
```c
#include <stdio.h>
#include <stdlib.h>

// 비교 로직을 함수 포인터로 전달
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int arr[] = {5, 2, 9, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    // qsort의 4번째 인자가 함수 포인터입니다.
    qsort(arr, n, sizeof(int), compare); 

    for(int i=0; i<n; i++) printf("%d ", arr[i]);
    return 0;
}
```

2. `qsort` 활용 예제_2
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct {
    int id;
    char name[20];
    double score;
}Student;

// 비교 로직을 함수 포인터로 전달

int compare_id(const void *a, const void *b) {
    Student* aa=(Student*)a;
    Student* bb=(Student*)b;
    
    return(aa->id-bb->id);
}

int compare_name(const void *a, const void *b) {
    
    Student* aa=(Student*)a;
    Student* bb=(Student*)b;
    
    return(strcmp(aa->name,bb->name));
    
}

int compare_score(const void *a, const void *b) {
    
    Student* aa=(Student*)a;
    Student* bb=(Student*)b;

    return(bb->score-aa->score);
}

int main() {
    
    Student students[5]={
        {101, "김철수", 85.5},
        {102, "이영희", 92.0},
        {103, "박민수", 78.5},
        {104, "최지우", 95.0},
        {105, "정수민", 88.5}
    };
    
    int n = sizeof(students) / sizeof(students[0]);
    int i;



    printf("\n");

    qsort(students,n,sizeof(Student),compare_id);
    printf("ID \t 이름 \t 점수 \n");
    for(i=0;i<n;i++){
        printf("%d\t%s\t %.1lf\n",students[i].id,students[i].name,students[i].score);
    }
    
    printf("\n");

    qsort(students,n,sizeof(Student),compare_name);
    printf("ID \t 이름 \t 점수 \n");
    for(i=0;i<n;i++){
        printf("%d\t%s\t %.1lf\n",students[i].id,students[i].name,students[i].score);
    }
    
    printf("\n");

    qsort(students,n,sizeof(Student),compare_score);
    printf("ID \t 이름 \t 점수 \n");
    for(i=0;i<n;i++){
        printf("%d\t%s\t %.1lf\n",students[i].id,students[i].name,students[i].score);
    }

   
    return 0;
}
```

진짜 이게 뭐라고 하루종일 진땀뺐네..

중요한점!!

1. `qsort()` 인자로 함수 포인터가 오는데, 이때 `compare (a,b)` 라는 함수가 음수인지, 양수인지, 0인지에 따라 배열이 달라진다.
- `compare(a,b) > 0` 일때 -> a를 뒤로 배치 (순서 b->a)
- `compare(a,b) < 0` 일때 -> a를 앞으로 배치 (순서 a->b)
- `compare(a,b) == 0` 일때 -> 상관 없음

2. `qsort()` 함수 원형
```c
void qsort{
	void *base,
    size_t nmemb,
    size_t size,
    int (*compar)(const void*, const void*)
}
```

함수 포인터의 인자로 `const` 가 온다.

++ 나중에 `const` 정리

### 5. 구조체를 이용한 객체지향(OOP) 흉내내기(Polymorphism)
C언어에는 클래스가 없지만, 구조체 안에 함수 포인터를 넣어 메서드(Method)처럼 사용할 수 있다. 이를 통해 다형성(Polymorphism)을 구현한다.

- 리눅스 커널 사례 : 리눅스 커널의 **VFS(가상 파일 시스템)**이 이 방식을 완벽하게 보여준다.
`file_operations` 구조체는 `read` , `write` , `open` 등의 함수 포인터를 가지고 있으며, 디바이스 드라이버마다 실제 동작 함수를 다르게 연결한다.

예시 코드 `like_oop.c`
```c
typedef struct {
    const char *name;
    void (*speak)(void); // 함수 포인터: 동작 정의
} Animal;

void dog_speak() { printf("멍멍\n"); }
void cat_speak() { printf("야옹\n"); }

int main() {
    // 같은 구조체지만 다른 동작을 연결
    Animal dog = {"강아지", dog_speak};
    Animal cat = {"고양이", cat_speak};

    dog.speak(); // 멍멍
    cat.speak(); // 야옹
    return 0;
}
```

<img width="665" height="383" alt="image" src="https://github.com/user-attachments/assets/b281c112-0cd3-4c1a-943e-218545090a45" />

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define SIZE 50

int main() {

	printf("A=%d, Z=%d, a=%d, z=%d\n\n", 'A', 'Z', 'a', 'z');

	char arr[SIZE];
	int cnt=0;

	printf("문장 입력 : ");
	fgets(arr, SIZE, stdin);

	for (int i = 0; i < SIZE; i++) {
		if (arr[i] >= 65 && arr[i] <= 90) {
			arr[i] += 32;
			cnt++;
		}
		printf("%c", arr[i]);
		if (arr[i] == '\0') break;
	}
	printf("\n바뀐 문자 수 : %d", cnt);

	return 0;
}
```

<img width="636" height="337" alt="image" src="https://github.com/user-attachments/assets/d10b8523-04f9-489a-9a12-3b006d784191" />

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void swap(double* x, double* y);

int main() {

	double a, b, c;
	double* pa, * pb, * pc;

	pa = &a;
	pb = &b;
	pc = &c;

	printf("실수값 3개 입력 : ");
	scanf("%lf %lf %lf", &a, &b, &c);
	
	swap(pa, pb);
	swap(pa, pc);
	swap(pb, pc);

	printf("정렬된 값 출력 : %.1lf %.1lf %.1lf", a, b, c);

	return 0;
}

void swap(double* x, double* y) {
	double temp;

	if (*x < *y) {
		temp = *x;
		*x = *y;
		*y = temp;
	}
}
```

<img width="661" height="586" alt="image" src="https://github.com/user-attachments/assets/9d75071a-5aa6-4abb-b245-40c0f5bcb3d7" />

<img width="695" height="601" alt="image" src="https://github.com/user-attachments/assets/2cecf8e7-4078-4c24-8ec9-958d4133366c" />

<img width="699" height="393" alt="image" src="https://github.com/user-attachments/assets/7bf4598e-26b6-416b-bc58-cd7195174069" />

