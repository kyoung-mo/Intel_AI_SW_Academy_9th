### p
```c
#include <stdio.h>

int main() {
    int ch;
    int max_word_length = 0;
    int cnt = 0;
    int loop = 1;

    do {
        do {
            ch = getchar();
            if(ch != '\n') cnt++;
            if (ch == -1) loop = 0;
        } while (ch != '\n');
        if (cnt > max_word_length) max_word_length = cnt;
        cnt = 0;
    } while (loop);
    printf("가장 긴 단어의 길이 : %d", max_word_length);

    return 0;
}
```

---

### 381p
```c
#include <stdio.h>
#include <string.h>

char* cmp(char* inStr);

int main() {
    char str[16];

    printf("단어 입력 : ");
    scanf("%s", str);
    printf("입력한 단어 : %s, 생략한 단어 : %s", str, cmp(str));

    return 0;
}

char* cmp(char* inStr) {
    static char resp[16];
    int i = 0;
    while (*inStr != '\0') {
        if (i < 5) resp[i++] = *inStr;
        else resp[i++] = '*';
        inStr++;
    }
    resp[i] = '\0';

    return resp;
}
```

---

### 389p - 전역변수
```c
#include <stdio.h>

void assign10();
void assign20();

int a;

int main() {
    
    printf("함수 호출 전 a값 : %d\n", a);

    assign10();
    assign20();

    printf("함수 호출 후 a값 : %d\n", a);
    return 0;
}


void assign10() {
    a = 10;
}
void assign20() {
    int a;
    a = 20;
}
```
함수 호출 전 a값 : 0
함수 호출 후 a값 : 10

C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 22680)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...

---
* 전역변수의 문제점
1) 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 합니다.
2) 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 합니다.
3) 코드 블록 내에 같은 이름의 지역변수를 선언하면 거기서는 전역 변수를 사용할 수 없습니다.
---


### 393p - 정적 지역 변수 (static)
```c
#include <stdio.h>

void auto_func(void);
void static_func(void);

int main() {
    
    int i;
    printf("일반 지역 변수(auto)를 사용한 함수...\n");

    for (i = 0; i < 3; i++) {
        auto_func();
    }

    printf("정적 지역 변수(static)을 사용한 함수...\n");

    for (i = 0; i < 3; i++) {
        static_func();
    }

    return 0;
}


void auto_func(void) {
    auto int a = 0;

    a++;
    printf("%d\n", a);
}
void static_func(void) {
    static int a;

    a++;
    printf("%d\n", a);
}
```

---
일반 지역 변수(auto)를 사용한 함수...
1
1
1
정적 지역 변수(static)을 사용한 함수...
1
2
3

C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 23908)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...

---

register(특수 목적의 기억 공간)1 - PC, SP 대표적인 레지스터. 어떤 역할을 하냐면 PC는 프로그램 카운터. 코드 영역의 주소를 가르키고 있는 포인터(지시자) 프로그램 실행하는경우 stack pointer는 책에 손가락 끼워두는 느낌. 북마크? 별도의 컴파일러를 통해 동작을 구현해볼예정

cpu 내부에 위치
cash memory(외부 메모리의 임시 버퍼) - 빈번하게 사용되는 데이터의 경우 캐시 메모리에 저장2
| SRAM(3) | DRAM(4) |
| 속도가 좀 더 빠름 | 좀 더 느림 |

---
13-2 함수의 데이터 공유 방법
1. 값을 복사해서 전달
2. 주소를 전달
3. 주소를 반환
### 400p
```c
#include <stdio.h>

void add_ten(int a);

int main() {
    
    int a = 10;
    add_ten(a);
    printf("%d", a);


    return 0;
}


void add_ten(int a) {
    a = a + 10;
}
```
---
10
C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 18340)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...

---

### 400p
```c
#include <stdio.h>

int add_ten(int a);

int main() {
    
    int a = 10;
    add_ten(a);
    printf("%d", a);


    return 0;
}


int add_ten(int a) {
    a = a + 10;
    return a;
}
```
---
10
C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 13584)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...

---

---

### 400p - 포인터 사용
```c
#include <stdio.h>

int add_ten(int *a);

int main() {
    
    int a = 10;
    add_ten(&a);
    printf("%d", a);


    return 0;
}


int add_ten(int *a) {
    *a = *a + 10;
}
```
---
20
C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 4716)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...


---


### 408p - 도전 실전 예제
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void input_data(int* pa, int* pb);
void swap_data(void);
void print_data(int a, int b);

int a, b;

int main() {
    input_data(&a, &b);
    print_data(a, b);
    swap_data();
    printf("=====swap_data======\n");
    print_data(a, b);

    return 0;
}


void input_data(int* pa, int* pb) {
    printf("a값 입력: ");
    scanf("%d", pa);
    printf("b값 입력: ");
    scanf("%d", pb);
}
void swap_data(void) {
    int temp;
    temp = b;
    b = a;
    a = temp;
}
void print_data(int a, int b) {
    printf("========print_data==========\n");
    printf("a = %d\n", a);
    printf("b = %d\n", b);
}

```

---
a값 입력: 10
b값 입력: 30
========print_data==========
a = 10
b = 30
=====swap_data======
========print_data==========
a = 30
b = 10

C:\Users\KCCISTC\source\repos\12-29\x64\Debug\12-29.exe(프로세스 18728)이(가) 0 코드(0x0)와 함께 종료되었습니다.
디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -> [옵션] -> [디버깅] > [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.
이 창을 닫으려면 아무 키나 누르세요...

---
