1. 15장, 16장, 17장 과제 리뷰
2. 전문가C -> 전처리기 지시자
3. 

---

전처리 : preprocssing

수행: 일련의 지시자를 사용해 통제하고 영향을 줌

C 지시자: 헤더와 소스 파일에서 #으로 시작하는 코드(매크로, 조건부 컴파일)

## 1.1 매크로

매크로의 활용 

- 상수 정의하기 ⇒ const
- C 함수를 작성하지 않고 함수로 사용하기 ⇒like function
- 루프 풀기
- 헤더 가드
- 코드 생성
- 조건부 컴파일


### 1.1.1 매크로의 장점과 단점

매크로는 컴파일 후 한 줄의 긴 코드로 교체되어 모듈성x

C 함수로 사용할 수 있다면 매크로 대신 C 함수로 작성

소프트웨어 설계와 디버깅 문제

루프 풀기와 성능 최적화

DSL 정의

### 1.1.2 조건부 컴파일

- `#ifdef CONDITION` ~ `enfif`
- 블럭 사이에 부분은 CONDITION이 어딘가에 정의되어 있지 않으면, 활성화 되지 않음.
- `gcc -DCONDITION -E main.c` 를 통해 컴파일하며 정의해줄 수 있음

-
```c
#inndef EXAMPLE_H
#define EXAMPLE_H

#endif
```

---

### 1.2 포인터 변수
- 포인터 : 메모리 주소를 저장하는 단순 변수
- 문서 상에는 `int* ptr = 0;` 으로 선언 시 꼭 초기화하라고 명시 되어있음.
- 널 포인터 선언, 참조 연산자 `&` , 역참조 연산자 `*`
- NULL 매크로 사용 : 변수와 포인터를 더 쉽게 구분

### 1.2.2 포인터 변수의 산술 연산
- 산술연산 간격? -> 포인터가 1씩 증감할때 움직이는 바이트의 숫자, C자료형을 기준으로 결정된다.
- `int형` 의 경우 4byte 씩, `char형` 의 경우 1byte 씩, 이동
- 포인터 산술 연산을 사용하지 않더라도, int형 및 char형 배열의 주소 크기도 동일하다.

### 1.2.3 제네릭 포인터 (`void*`)
- `void*` 자료형의 포인터.
- **역참조 불가능** 
- `void* vp=&a` 가 있을때 역참조는 `*vp` (불가능)
- 받는건 어떤 자료형이든 무조건 받고, 사용할 때 문제가 된다.

### 1.2.4 포인터늬 크기
- 아키텍처에 따라 포인터의 크기가 다름
- 대상 아키텍처에서 `sizeof 함수` 를 사용

### 1.2.5 허상 포인터 - danggling
- 충돌 또는 세그멘테이션 오류 발생
- ptr 포인터가 할당이 해제된 var의 메모리 영역을 가리킴(허상 포인터)

---

### 1.3 함수
- 이름, 입력 매개변수의 목록, 출력 결과의 목록을 가진 논리 상자
- 블로킹 함수 : 호출된 함수가 종료되어야만 반환값을 호출자 함수가 받을 수 있음.
- 논 블로킹 함수 : 콜백 메커니즘, 비동기 함수, 사건 기반 프로그래밍(EDP)

- 로직을 만들면 여러 곳에서 사용 가능
- 추상화 : 기존의 다른 로직으로부터 일부를 숨김(encapsulation ? )
- 스택 관리 : 스택 세그먼트 -> 모든 지역 변수, 배열, 구조체가 할당되는 기본 메모리의 위치
- 스택 프레임 -> 스택 세그먼트의 가장 위에 놓이고, 함수 로직이 실행된다. 호출이 끝나면 스택 프레임은 제거되며 직전 호출 함수로 계속 이어진다.

---

### 1.4 함수 포인터
- 함수의 주소를 저장하는 포인터, 간접적으로 호출 가능
- 이로 인해 모듈화가 가능해졌다.

- 함수 포인터 선언 : `int (*fptr)(int)` << 해당함수의 반환형, 포인터변수, 해당함수의 매개변수의 형태 순서
- C에는 `bool` 변수가 없었으나, `<stdio.h>` 가 업데이트 되면서 아래와 같이 사용
```c
typedef int bool_t;
typedef bool_t(*less_than_func_t)(int,int);
```

---

### 1.5 구조체
- 원시 자료형(PDT) = 자료구조를 설계할 수 있고, 알고리즘을 작성할 수 있습니다.
- 하나 이상의 변수를 묶어서 사용할 수 있는 복잡 자료형
- 캡슐화(encapsulation) 가능 == 은닉화

- 왜 사용자 정의 자료형을 사용하는가?
- 서로 연관된 속성을 그룹으로 묶기 위해.
- 배열의 경우 같은 타입의 자료형만 가능한데, 구조체의 경우 여러 자료형을 묶어서 관리할 수 있음.
- 비즈니스 로직(도메인 지식) - 은행(고객, 잔고, 돈, 현금, 지불) 개념을 마주하고, 은행 로직을 개발하기 위해서는 개발자와 비즈니스 분석가는 협력하며 규칙, 로직, 용어집 등을 공유해야 한다.

```c
struct color_t{
  int red;
  int green;
  int blue;
};
```

- 위 구조와 같이 서로 관련이 있는 필드(red, green, blue)를 캡슐화를 할 수 있음
- 구조체 변수가 할당되는 순서에 따라 바이트 수가 달라질 수 있다.
- 구조체 포인터를 통해 사용하는 경우가 많다.
- 사용자 정의 자료형의 포인터는 원시 자료형의 포인터와 동일
- 구조체 변수 포인터가 구조체 변수의 첫 번째 필드의 주소를 가르킨다.

헷갈리는 예제)
- p2와 p3의 주소값이 왜 같은가?
- p4, p5는 각각 double*, char*형 으로 형변환 해주었는데 왜 같은 주소값이 나오는가?
- 그럼 저게 무슨 의미인가? 
  
```c
#include <stdio.h>

typedef struct {
	int x;
	int y;
}point_t;

typedef struct {
	point_t center;
	int radius;
}circle_t;

int main(void)
{
	circle_t c;
	c.radius = 10;
	c.center.x = 100;
	c.center.y = 200;

	circle_t* p1 = &c;
	point_t* p2 = (point_t*)&c;
	int* p3 = (int*)&c;
	double* p4 = (double*)&c;
	char* p5 = (char*)&c;

	printf("p1 = %p\n", (void*)p1);
	printf("p2 = %p\n", (void*)p2);
	printf("p3 = %d\n", *p3);
	printf("p4 = %p\n", (void*)p4);
	printf("p5 = %p\n", (void*)p5);
	return 0;
}
```

---

### 2.1 표준 컴파일 파이프라인
- 전처리기 / 컴파일러 / 어셈블러 / 링커 : 네 가지 요소로 구성된 파이프 라인
- 
- **재배치 가능한 목적파일**과 같은 어떤 중간 결과물은 소스파일 하나가 세 가지 요소(전처리기, 컴파일러, 어셈블러)만 성공적으로 통과하면 만들어짐
- 주소는 재배치 가능한 목적파일(오브젝트 코드) 를 가져와서 각 세그먼트별로 데이터를 뽑아와서 하나의 데이터 영역을 만들고, 코드 영역도 쭉 뽑아와서 코드 영역을 만든다.
- 데이터 영역, 코드 영역을 만들면 주소가 확정된다.

##### 플랫폼
- 하드웨어에서 실행되는 운영체제의 결합
- 크로스 플랫폼은 (Intel용 이진파일, Arm용 이진파일 등등) 각 플랫폼마다 이진파일이 다르다.
- 이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진파일과 인스톨러를 사용
  - gcc와 clang 같은 C컴파일러는 크로스 플랫폼 -> 컴파일 해야만 실행 가능, 자바의 바이트 코드는 이식 가능 -> 그냥 실행 가능
  - 윈도우에서 컴파일한 파일 -> Arm코어에서 실행 불가 .. 이런 느낌이 크로스 플랫폼, 하지만 자바의 바이트 코드는 둘 다 실행 o
  - C/C++ 코드가 이식 가능하다? -> 따로 변경, 수정을 거치지 않아도 서로 다른 플랫폼에서 컴파일 할 수 있다는 말.
  - 최종 목적 파일에 이식성이 있다는 의미가 아님

### 2.1.1 프로젝트 빌드
- 헤더 파일 : .h (굳이 .h로 안해도 괜찮음)
- 소스 파일 : .c
- 헤더 파일은 주로 열거형, 매크로, 형식 정의, 함수의 선언, 전역변수, 구조체도 포함한다.
- 함수 선언(declare) -> `double average(int*, int);` , 함수 정의(definition) -> 중괄호 열고 함수 몸통 포함되어 있는 것
- 소스 파일 중 하나는 `main` 함수를 포함하는데, 프로그램의 진입점(entry-point)이다.
- main 함수 없이는 프로그램의 실행 파일을 가질 수 없다.
- 컴파일러는 프로그램 시작점으로 `main()` 을 찾는다.

- 전방 선언 : 컴파일을 한번에 (함수를 정의하기 이전에 함수를 선언)
- 헤더 가드문 : 헤더 파일이 컴파일 될 때 두 번 또는 그 이상 포함되는 것을 방지한다.
- 규칙 1. 소스파일만 컴파일, 헤더 파일은 컴파일 하지 않는다.
- 규칙 2. 각 소스 파일을 따로따로 컴파일한다. 한번에 여러 파일을 컴파일 하지 않는다.

### 2.1.2) 1단계 : 전처리
- 컴파일 파이프라인의 첫 단계 : 전처리
- 컴파일이 시작되기 전에 전처리기가 헤더 파일의 내용을 모아 하나의 C코드 몸체로 만든다.
- 이후 전처리 지시자(`#include` , `#define` 등)는 이 단계에서 해결된다.
- 전처리된 코드는 변환단위, 혹은 컴파일 단위라고 한다.

assembly 코드 보기 편하게하는 vscode extension

<img width="926" height="757" alt="image" src="https://github.com/user-attachments/assets/3cbc3953-0616-4b86-a97f-b6b84b7f179a" />


<img width="557" height="444" alt="image" src="https://github.com/user-attachments/assets/849c7942-ed54-444a-b42a-a520b117f73f" />

- offset 값이니까 맨 위에서부터 `-12(%rbp)` 등등
- intel용으로 컴파일
 
<img width="632" height="433" alt="image" src="https://github.com/user-attachments/assets/0b65c49e-7b01-42e0-8073-0880d796a44a" />

- x86용은 명령어 뒤에 인자가 2개가 아니라 3개, 4개 등 나올 수 있다.
- 한번에 두개를 비교해서 다른 레지스터에 저장, 한번에 3가지 4가지 등을 처리할 수 있는 복잡한 명령어가 많음
- 복잡한 명령어 셋을 가지고 있는 ? 라고함
- 여러개의 명령어 가지고 한번에 처리 할수있음(?)
- x86은 복잡, 속도 빠름 / 전력 효율이 안 좋다는 단점
- Arm은 구조가 단순, 간단. 핸드폰에 들어가는 코어는 대부분 Arm코어, 전력 효율이 좋은 편 / 저전력

- 대상 아키텍처 : 소스 파일이 컴파일되어 실행될 아키텍처
- 빌드 아키텍처 : 소스를 컴파일 할 때 사용하는 아키텍처
- 예를 들어 ARM 32비트 머신(빌드 아키텍처)에서 AMD 64비트 하드웨어(대상 아키텍처)를 위한 C소스를 컴파일 할 수 있다.

### 2.1.4) 3단계 : 어셈블리
- 입력값 : 어셈블리 코드 출력값 : 재배치 가능한 목적 파일(기계어 코드, 중간 목적 파일)
- 유닉스 계열 운영체제에서 어셈블러 도구는 `as` 이다.
  `as ExtremeC_examples_chapter2_1.s -o ExtremeC_examples_chapter2_1.o`
- 재배치 가능한 목적 파일은 .o 확장자
- 어셈블리 코드로 목적 파일을 생성 가능
```c
gcc -c ExtremeC_examples_chapter2_1.c -o impl.o
gcc -c ExtremeC_examples_chapter2_1_main.c -o main.o
```

### 2.1.5) 4단계 : 링크
- 입력값 : 목적파일 결과값 : 실행파일

```
$ ld impl.o main.o
113쪽
$ gcc impl.o main.o
$ ./a.out
```

---

### 3.1 ABI
- ABI, API는 수준(level)이 다르다.
  
- API : 두 소프트웨어의 컴포넌트 간 호환성을 보장하여 기능적으로 계속 협력할 수 있도록 한다.
- ABI : 두 프로그램이 명령어 수준에서 호환 가능하도록 두 프로그램 목적 파일을 함께 사용할 수 있게 한다.
  
- ABI가 포함하는 내용
  - 대상 아키텍처의 명령어 집합
  - 기존의 자료형과 크기 및 정렬 규칙
  - 함수 호출 규칙
  - 유닉스 계열 시스템에서 시스템 호출 방식 정의를 많이 따라감
  - 사용된 목적 파일 형식: 재배치 가능한 실행 가능한, 공유 목적 파일에 관한 내용

### nm - 심볼 테이블 확인
- 바이너리의 심볼을 볼 때 사용하는 명령어
- `nm {binary_file_name}` 명령어 통해 사용

<img width="718" height="562" alt="image" src="https://github.com/user-attachments/assets/924139c0-c2d6-4165-bb67-98bdae899a9d" />

- 두 번째 필드의 종류
- 언더바(`_`)가 붙어있는건 자동으로 로딩된 파일

| 심볼 타입 명 | 설명 |
| --- | --- |
| A | 주소가 절대적이어서 변경되지 않는 심볼 |
| B | 심볼이 BSS 섹션에 존재(un-initialized global varible 등) |
| C | 공통 심볼(un-initialized data) |
| D | 심볼이 data 섹션에 위치(initialized global variable 등) |
| G | 작은 공간의 전역 객체, data 섹션에 위치(initialized data 등) |
| I | 심볼이 다른 심볼의 indirect |
| N | 디버그 심볼 |
| R | Read-only 섹션에 존재 |
| S | 작은 객체를 위한 BSS 섹션의 심볼 |
| T | text 섹션에 있는 심볼(code) |
| U | 정의되지 않은 심볼 |
| V | 확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나면 변경 |
| W | 확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나지 못하면 0으로 설정 |
| - | stabs 심볼 |
| ? | 알수없는 심볼 |

### 3.2 목적 파일 형식
- 목적 파일(Object file) : 플랫폼에서 목적 파일에는 기계 수준의 명령어를 저장하는 목적 파일만의 특정 파일 형식이 존재

<img width="309" height="131" alt="image" src="https://github.com/user-attachments/assets/bc83ee9b-e0bf-4863-9706-2fcdb3226711" />

### 3.4 실행 가능한 목적 파일
- 실행 가능한 목적 파일이 C 언어의 프로젝트의 최종 결과물중 하나일까?
- 실행 가능한 목적 파일도 재배치 가능한 목적 파일처럼 기계 수준의 명령어, 초기화된 전역 변수값, 심벌테이블과 같은 항목을 가진다.
- 하지만 정렬(arrangement)는 다를 수 있다.
- Magic 부분만 보고 실행 가능한 파일인지 확인할 수 있다.

`readelf -hSl ./main_shared_app`

<img width="830" height="1002" alt="image" src="https://github.com/user-attachments/assets/afd36dad-bed6-49ac-9693-307cd101d835" />

<img width="922" height="905" alt="image" src="https://github.com/user-attachments/assets/336b69ef-4b7d-4266-90db-55a52565bb89" />




