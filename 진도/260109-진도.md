1. 15장, 16장, 17장 과제 리뷰
2. 전문가C -> 전처리기 지시자
3. 

---

전처리 : preprocssing

- 수행: 일련의 지시자(#)를 사용해 통제하고 영향을 줌
- C 지시자: 헤더와 소스 파일에서 #으로 시작하는 코드(매크로, 조건부 컴파일)

### 1.1.1 매크로

매크로의 활용 

- 상수 정의 ⇒ const
- C 함수를 작성하지 않고 함수로 사용하기 ⇒like function
- 루프 풀기
- 헤더 가드
- 코드 생성
- 조건부 컴파일
- `#define` 지시자를 이용해 정의 : 각 매크로는 이름과 파라미터, 값을 가짐
- `#undef` 지시자로 정의를 제거
- 매크로는 컴파일 이전 단계에서만 존재, 이론적으로는 컴파일러가 매크로에 관해 모른다는 뜻
- 하지만 현대의 C 컴파일러는 전처리 단계를 알고있다.
- int 함수 쓰임?


### 1.1.2 조건부 컴파일

- `#ifdef CONDITION` ~ `enfif`
- 블럭 사이에 부분은 CONDITION이 어딘가에 정의되어 있지 않으면, 활성화 되지 않음.
- `gcc -DCONDITION -E main.c` 를 통해 컴파일하며 정의해줄 수 있음

-
```c
#inndef EXAMPLE_H
#define EXAMPLE_H

#endif
```

---

### 1.2 포인터 변수
- 포인터 : 메모리 주소를 저장하는 단순 변수
- 문서 상에는 `int* ptr = 0;` 으로 선언 시 꼭 초기화하라고 명시 되어있음.
- 널 포인터 선언, 참조 연산자 `&` , 역참조 연산자 `*`
- NULL 매크로 사용 : 변수와 포인터를 더 쉽게 구분

### 1.2.2 포인터 변수의 산술 연산
- 산술연산 간격? -> 포인터가 1씩 증감할때 움직이는 바이트의 숫자, C자료형을 기준으로 결정된다.
- `int형` 의 경우 4byte 씩, `char형` 의 경우 1byte 씩, 이동
- 포인터 산술 연산을 사용하지 않더라도, int형 및 char형 배열의 주소 크기도 동일하다.

### 1.2.3 제네릭 포인터 (`void*`)
- `void*` 자료형의 포인터.
- **역참조 불가능** 
- `void* vp=&a` 가 있을때 역참조는 `*vp` (불가능)
- 받는건 어떤 자료형이든 무조건 받고, 사용할 때 문제가 된다.

### 1.2.4 포인터늬 크기
- 아키텍처에 따라 포인터의 크기가 다름
- 대상 아키텍처에서 `sizeof 함수` 를 사용

### 1.2.5 허상 포인터 - danggling
- 충돌 또는 세그멘테이션 오류 발생
- ptr 포인터가 할당이 해제된 var의 메모리 영역을 가리킴(허상 포인터)

---

### 1.3 함수
- 이름, 입력 매개변수의 목록, 출력 결과의 목록을 가진 논리 상자
- 블로킹 함수 : 호출된 함수가 종료되어야만 반환값을 호출자 함수가 받을 수 있음.
- 논 블로킹 함수 : 콜백 메커니즘, 비동기 함수, 사건 기반 프로그래밍(EDP)

- 로직을 만들면 여러 곳에서 사용 가능
- 추상화 : 기존의 다른 로직으로부터 일부를 숨김(encapsulation ? )
- 스택 관리 : 스택 세그먼트 -> 모든 지역 변수, 배열, 구조체가 할당되는 기본 메모리의 위치
- 스택 프레임 -> 스택 세그먼트의 가장 위에 놓이고, 함수 로직이 실행된다. 호출이 끝나면 스택 프레임은 제거되며 직전 호출 함수로 계속 이어진다.

---

### 1.4 함수 포인터
- 함수의 주소를 저장하는 포인터, 간접적으로 호출 가능
- 이로 인해 모듈화가 가능해졌다.

- 함수 포인터 선언 : `int (*fptr)(int)` << 해당함수의 반환형, 포인터변수, 해당함수의 매개변수의 형태 순서
- C에는 `bool` 변수가 없었으나, `<stdio.h>` 가 업데이트 되면서 아래와 같이 사용
```c
typedef int bool_t;
typedef bool_t(*less_than_func_t)(int,int);
```

---

### 1.5 구조체
- 원시 자료형(PDT) = 자료구조를 설계할 수 있고, 알고리즘을 작성할 수 있습니다.
- 하나 이상의 변수를 묶어서 사용할 수 있는 복잡 자료형
- 캡슐화(encapsulation) 가능 == 은닉화

- 왜 사용자 정의 자료형을 사용하는가?
- 서로 연관된 속성을 그룹으로 묶기 위해.
- 배열의 경우 같은 타입의 자료형만 가능한데, 구조체의 경우 여러 자료형을 묶어서 관리할 수 있음.
- 비즈니스 로직(도메인 지식) - 은행(고객, 잔고, 돈, 현금, 지불) 개념을 마주하고, 은행 로직을 개발하기 위해서는 개발자와 비즈니스 분석가는 협력하며 규칙, 로직, 용어집 등을 공유해야 한다.

```c
struct color_t{
  int red;
  int green;
  int blue;
};
```

- 위 구조와 같이 서로 관련이 있는 필드(red, green, blue)를 캡슐화를 할 수 있음
- 구조체 변수가 할당되는 순서에 따라 바이트 수가 달라질 수 있다.
- 구조체 포인터를 통해 사용하는 경우가 많다.
- 사용자 정의 자료형의 포인터는 원시 자료형의 포인터와 동일
- 구조체 변수 포인터가 구조체 변수의 첫 번째 필드의 주소를 가르킨다.

헷갈리는 예제)
- p2와 p3의 주소값이 왜 같은가? -> &C를 받았으니까
- p4, p5는 각각 double*, char*형 으로 형변환 해주었는데 왜 같은 주소값이 나오는가? -> 같은 이유
- 그럼 저게 무슨 의미인가? -> 어떤 자료형이든 상관없이 포인터 변수에 같은 C의 값을 저장 출력
  
```c
#include <stdio.h>

typedef struct {
	int x;
	int y;
}point_t;

typedef struct {
	point_t center;
	int radius;
}circle_t;

int main(void)
{
	circle_t c;
	c.radius = 10;
	c.center.x = 100;
	c.center.y = 200;

	circle_t* p1 = &c;
	point_t* p2 = (point_t*)&c;
	int* p3 = (int*)&c;
	double* p4 = (double*)&c;
	char* p5 = (char*)&c;

	printf("p1 = %p\n", (void*)p1);
	printf("p2 = %p\n", (void*)p2);
	printf("p3 = %d\n", *p3);
	printf("p4 = %p\n", (void*)p4);
	printf("p5 = %p\n", (void*)p5);
	return 0;
}
```

---

### 2.1 표준 컴파일 파이프라인
- 전처리기 / 컴파일러 / 어셈블러 / 링커 : 네 가지 요소로 구성된 파이프 라인
- 
- **재배치 가능한 목적파일**과 같은 어떤 중간 결과물은 소스파일 하나가 세 가지 요소(전처리기, 컴파일러, 어셈블러)만 성공적으로 통과하면 만들어짐
- 주소는 재배치 가능한 목적파일(오브젝트 코드) 를 가져와서 각 세그먼트별로 데이터를 뽑아와서 하나의 데이터 영역을 만들고, 코드 영역도 쭉 뽑아와서 코드 영역을 만든다.
- 데이터 영역, 코드 영역을 만들면 주소가 확정된다.

##### 플랫폼
- 하드웨어에서 실행되는 운영체제의 결합
- 크로스 플랫폼은 (Intel용 이진파일, Arm용 이진파일 등등) 각 플랫폼마다 이진파일이 다르다.
- 이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진파일과 인스톨러를 사용
  - gcc와 clang 같은 C컴파일러는 크로스 플랫폼 -> 컴파일 해야만 실행 가능, 자바의 바이트 코드는 이식 가능 -> 그냥 실행 가능
  - 윈도우에서 컴파일한 파일 -> Arm코어에서 실행 불가 .. 이런 느낌이 크로스 플랫폼, 하지만 자바의 바이트 코드는 둘 다 실행 o
  - C/C++ 코드가 이식 가능하다? -> 따로 변경, 수정을 거치지 않아도 서로 다른 플랫폼에서 컴파일 할 수 있다는 말.
  - 최종 목적 파일에 이식성이 있다는 의미가 아님

### 2.1.1 프로젝트 빌드
- 헤더 파일 : .h (굳이 .h로 안해도 괜찮음)
- 소스 파일 : .c
- 헤더 파일은 주로 열거형, 매크로, 형식 정의, 함수의 선언, 전역변수, 구조체도 포함한다.
- 함수 선언(declare) -> `double average(int*, int);` , 함수 정의(definition) -> 중괄호 열고 함수 몸통 포함되어 있는 것
- 소스 파일 중 하나는 `main` 함수를 포함하는데, 프로그램의 진입점(entry-point)이다.
- main 함수 없이는 프로그램의 실행 파일을 가질 수 없다.
- 컴파일러는 프로그램 시작점으로 `main()` 을 찾는다.

- 전방 선언 : 컴파일을 한번에 (함수를 정의하기 이전에 함수를 선언)
- 헤더 가드문 : 헤더 파일이 컴파일 될 때 두 번 또는 그 이상 포함되는 것을 방지한다.
- 규칙 1. 소스파일만 컴파일, 헤더 파일은 컴파일 하지 않는다.
- 규칙 2. 각 소스 파일을 따로따로 컴파일한다. 한번에 여러 파일을 컴파일 하지 않는다.

### 2.1.2) 1단계 : 전처리
- 컴파일 파이프라인의 첫 단계 : 전처리
- 컴파일이 시작되기 전에 전처리기가 헤더 파일의 내용을 모아 하나의 C코드 몸체로 만든다.
- 이후 전처리 지시자(`#include` , `#define` 등)는 이 단계에서 해결된다.
- 전처리된 코드는 변환단위, 혹은 컴파일 단위라고 한다.

### 2.1.3) 2단계 : 컴파
assembly 코드 보기 편하게하는 vscode extension

<img width="926" height="757" alt="image" src="https://github.com/user-attachments/assets/3cbc3953-0616-4b86-a97f-b6b84b7f179a" />


<img width="557" height="444" alt="image" src="https://github.com/user-attachments/assets/849c7942-ed54-444a-b42a-a520b117f73f" />

- offset 값이니까 맨 위에서부터 `-12(%rbp)` 등등
- intel용으로 컴파일
 
<img width="632" height="433" alt="image" src="https://github.com/user-attachments/assets/0b65c49e-7b01-42e0-8073-0880d796a44a" />

- x86용은 명령어 뒤에 인자가 2개가 아니라 3개, 4개 등 나올 수 있다.
- 한번에 두개를 비교해서 다른 레지스터에 저장, 한번에 3가지 4가지 등을 처리할 수 있는 복잡한 명령어가 많음
- 복잡한 명령어 셋을 가지고 있는 ? 라고함
- 여러개의 명령어 가지고 한번에 처리 할수있음(?)
- x86은 복잡, 속도 빠름 / 전력 효율이 안 좋다는 단점
- Arm은 구조가 단순, 간단. 핸드폰에 들어가는 코어는 대부분 Arm코어, 전력 효율이 좋은 편 / 저전력

- 대상 아키텍처 : 소스 파일이 컴파일되어 실행될 아키텍처
- 빌드 아키텍처 : 소스를 컴파일 할 때 사용하는 아키텍처
- 예를 들어 ARM 32비트 머신(빌드 아키텍처)에서 AMD 64비트 하드웨어(대상 아키텍처)를 위한 C소스를 컴파일 할 수 있다.

### 2.1.4) 3단계 : 어셈블리
- 입력값 : 어셈블리 코드 출력값 : 재배치 가능한 목적 파일(기계어 코드, 중간 목적 파일)
- 유닉스 계열 운영체제에서 어셈블러 도구는 `as` 이다.
  `as ExtremeC_examples_chapter2_1.s -o ExtremeC_examples_chapter2_1.o`
- 재배치 가능한 목적 파일은 .o 확장자
- 어셈블리 코드로 목적 파일을 생성 가능
```c
gcc -c ExtremeC_examples_chapter2_1.c -o impl.o
gcc -c ExtremeC_examples_chapter2_1_main.c -o main.o
```

### 2.1.5) 4단계 : 링크
- 입력값 : 목적파일 결과값 : 실행파일

```
$ ld impl.o main.o
113쪽
$ gcc impl.o main.o
$ ./a.out
```

---

### 3.1 ABI
- ABI, API는 수준(level)이 다르다.
  
- API : 두 소프트웨어의 컴포넌트 간 호환성을 보장하여 기능적으로 계속 협력할 수 있도록 한다.
- ABI : 두 프로그램이 명령어 수준에서 호환 가능하도록 두 프로그램 목적 파일을 함께 사용할 수 있게 한다.
  
- ABI가 포함하는 내용
  - 대상 아키텍처의 명령어 집합
  - 기존의 자료형과 크기 및 정렬 규칙
  - 함수 호출 규칙
  - 유닉스 계열 시스템에서 시스템 호출 방식 정의를 많이 따라감
  - 사용된 목적 파일 형식: 재배치 가능한 실행 가능한, 공유 목적 파일에 관한 내용

### nm - 심볼 테이블 확인
- 바이너리의 심볼을 볼 때 사용하는 명령어
- `nm {binary_file_name}` 명령어 통해 사용

<img width="718" height="562" alt="image" src="https://github.com/user-attachments/assets/924139c0-c2d6-4165-bb67-98bdae899a9d" />

- 두 번째 필드의 종류
- 언더바(`_`)가 붙어있는건 자동으로 로딩된 파일

| 심볼 타입 명 | 설명 |
| --- | --- |
| A | 주소가 절대적이어서 변경되지 않는 심볼 |
| B | 심볼이 BSS 섹션에 존재(un-initialized global varible 등) |
| C | 공통 심볼(un-initialized data) |
| D | 심볼이 data 섹션에 위치(initialized global variable 등) |
| G | 작은 공간의 전역 객체, data 섹션에 위치(initialized data 등) |
| I | 심볼이 다른 심볼의 indirect |
| N | 디버그 심볼 |
| R | Read-only 섹션에 존재 |
| S | 작은 객체를 위한 BSS 섹션의 심볼 |
| T | text 섹션에 있는 심볼(code) |
| U | 정의되지 않은 심볼 |
| V | 확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나면 변경 |
| W | 확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나지 못하면 0으로 설정 |
| - | stabs 심볼 |
| ? | 알수없는 심볼 |

### 3.2 목적 파일 형식
- 목적 파일(Object file) : 플랫폼에서 목적 파일에는 기계 수준의 명령어를 저장하는 목적 파일만의 특정 파일 형식이 존재

<img width="309" height="131" alt="image" src="https://github.com/user-attachments/assets/bc83ee9b-e0bf-4863-9706-2fcdb3226711" />

### 3.3 재배치 가능한 목적 파일
- 재배치 가능한(relocatable) 의미? -> 링커가 작업을 수행하는 과정에서 비록된 의미
- 링커는 재배치 가능한 목적 파일 여러 개를 한데 모아서 더 큰 목적 파일을 형성하는데, 이 파일은 실행가능한 목적 파일 혹은 공유 목적 파일이라고 한다
- 실행 가능한 목적 파일에서 찾아볼 수 있는 항목은 이 파일을 구성하는 모든 재배치 가능한 목적 파일에서 찾아볼 수 있는 항목의 총합이라는 점
- 하나의 재배치 가능한 목적 파일에서 나타나는 기계 수준의 명령어는 다른 재배치 가능한 목적파일에서 나온 기계 수준의 명령어 다음에 위치
- 즉 명령어가 이동할 수 있거나 재배치 가능(relocatable) 하다는 점을 의미
- 재배치 가능한 목적 파일에서 명령어는 주소를 갖지 않고 링크 단계를 거치고 나서야 주소를 가짐



### 3.4 실행 가능한 목적 파일
- 실행 가능한 목적 파일이 C 언어의 프로젝트의 최종 결과물중 하나일까?
- 실행 가능한 목적 파일도 재배치 가능한 목적 파일처럼 기계 수준의 명령어, 초기화된 전역 변수값, 심벌테이블과 같은 항목을 가진다.
- 하지만 정렬(arrangement)는 다를 수 있다.
- Magic 부분만 보고 실행 가능한 파일인지 확인할 수 있다.

`readelf -hSl ./main_shared_app`

<img width="830" height="1002" alt="image" src="https://github.com/user-attachments/assets/afd36dad-bed6-49ac-9693-307cd101d835" />

<img width="922" height="905" alt="image" src="https://github.com/user-attachments/assets/336b69ef-4b7d-4266-90db-55a52565bb89" />

- 세그먼트 4개
- 1. INTERP 세그먼트 : 첫 번째 항목에서 설명?
  2. TEXT 세그먼트 : 기계 수준의 명령어를 갖는 섹션을 모두 포함
  3. DATA 세그먼트 : 전역 변수를 초기화할 때 사용할 모든 값과 다른 초기 구조체 포함
  4. 동적 링크 dynamic linking과 관련한 정보를 찾을 수 있는 섹션

- 실행 가능한 목적 파일에서 찾아볼 수 있는 심벌 테이블

`readelf -s ./main_shared_app`

<img width="791" height="937" alt="image" src="https://github.com/user-attachments/assets/737bed8a-fda9-4433-be34-b8b639b91fb4" />

### 3.5 정적 라이브러리
- C 프로젝트에서 얻을 수 있는 결과물
- 주소가 확정되지 않은 목적 파일이고, 다른 목적파일들과 링크되어 최종적으로 실행 가능한 목적 파일을 형성
- 리눅스의 정적 라이브러리는 `ELF 파일`
- 유닉스의 `ar` 유틸리티로 파일을 아카이브
- 링커가 링크 단계에서 정적 라이브러리 사용할 때, 배치 가능한 목적 파일에서 정적 라이브러리 추출하려고 시도하고, 정의되지 않은 심벌을 찾아 해결

- 규칙
- 1. 이름은 `lib` 로 시작하고 `.a` 확장자 -> 리눅스 `libmath.a`
  2. 정적 라이브러리에 `.lib` 확장자 -> 윈도우
 
- 여러 소스 파일을 그에 해당하는 재배치 가능한 목적 파일로 컴파일하기
``` 
gcc -c aa.c -o aa.o
gcc -c aa.c -o aa.o
gcc -c aa.c -o aa.o
```

## 3.6 동적 라이브러리
- 재사용 위한 라이브러리 만드는 또 다른 방식
- 동적 라이브러리는 실행을 위한 프로세스가 로딩될 때 가져와서 로드
- 정의되지 않은 심벌을 가질 수 있다.
- 정의되지 않은 심벌은 링크 단계에서 해결되지 않는다.

- ELP 실행 파일 및 공유 목적 파일은 각자의 ELP 구조 내에 세그먼트가 있다.
- ELP 실행 가능한 목적 파일과 ELF 공유 목적 파일 간에 주요 차이점
  - 심벌이 상대적인 절대 주소를 가지며 이 주소를 통해 심벌이 여러 프로세스에 동시에 로드
  - 각 명령어의 주소가 프로세스에서 다른 한편, 두 명령어 사이의 거리는 고정되어 있음을 의미
  - 다시 말하면 주소는 오프셋(offset)에 상대적으로 고정
  - 재배치 가능한 목적 파일이 위치 독립적(position independent)
 
---

### 4.1 프로세스 메모리 레이아웃
- C언어에서는 메모리를 수동으로 관리해주어야 함
- 메모리 영역을 할당하거나, 더이상 필요하지 않은 메모리를 해제하는 일은 개발자만이 담당
- 프로세스 = 실행중인 프로그램
- 메모리 레이아웃

  <img width="1400" height="619" alt="image" src="https://github.com/user-attachments/assets/71d24184-878b-4015-924c-41b7376cc184" />

- 동적 메모리 레이아웃 세그먼트 = 스택과 힙
- 정적 메모리 레이아웃 세그먼트 = BSS, DATA, TEXT
- 모든 메모리 할당과 해제는 이 세그먼트에서 일어난다.

### 4.2 메모리 구조 알아보기
- 실행 가능한 목적파일 vs 프로세스

|  | 실행 가능한 목적 파일 | 프로세스 |
| --- | --- | --- |
|  | 기계 명령어를 포함하며 컴파일러에 의해 생성됩니다. | 실행 중인 프로그램이며 실행 가능한 목적 파일에 의해 스폰-Spawn(프로세서를 호출)된 것입니다. |
|  |  | 메인 메모리 영역을 소비하며, CPU는 계속 메모리의 명령어를 가져와서 실행됩니다. |
| 세그먼트 | 실행 가능한 목적 파일에 탑재된 세그먼트 | 프로세스가 로딩되는 동안 만들어지는 세그먼트 |
|  | BSS , DATA , TEXT |  스택 , 힙 |


<img width="1251" height="115" alt="image" src="https://github.com/user-attachments/assets/9d2119d5-bd05-4e9b-a3f6-f7b4209ae03e" />

<img width="1259" height="138" alt="image" src="https://github.com/user-attachments/assets/0fa36742-3935-4ebc-8f6a-b507045c5bed" />

- PS와, PPID
- 45789	40047 > 40047의 parents pid
- 하나의 프로그램 실행되면 PID를 가짐
- 새 프로그램이 실행되면 PID가 어디서 부터 왔느냐? => PPID (부모 프로세스 아이디)
- PPID가 0이면 더 이상 없는 것. 확인해보면 root가 PID 1번, PPID 0번
- `root           1       0  0 11:04 ?        00:00:01 /sbin/init`

- 정적 메모리 레이아웃 vs 동적 메모리 레이아웃

| 레이아웃 종류 | 정적 메모리 레이아웃 | 동적 메모리 레이아웃 |
| --- | --- | --- |
| 세그먼트 | 세그먼트의 집합 | 세그먼트의 집합 |
|  | BSS, DATA, TEXT | 스택 , 힙 |
| 레이아웃 생성 | 실행 중인 프로세스의 메모리 아웃에서, 토대가 되는 실행 가능한 목적 파일에서 직접 생성됩니다. | 프로세스가 로딩될 때, 프로그램이 실행되는 동안 동적으로 생성됩니다. |
| 레이아웃 내용 | 내용은 소스 코드를 컴파일할 때 컴파일러가 실행 가능한 목적 파일에 미리 작성합니다. | 내용은 프로그램의 명령어에 따라 작성됩니다 |
|  |  | 프로그램 명령어 → 변수와 배열에 메모리를 할당하며, 프로그램의 로직에 따라 변수와 배열을 수정합니다. |
| 레이아웃 내용을 추측 가능할까? | 소스 코드나 컴파일된 목적 파일만 봐도 정적 메모리 레이아웃의 내용을 추측 가능합니다. | 내용은 프로그램을 실행하지 않으면 결정되지 않으므로 쉽게 알  수 없습니다. 게다가 같은 실행 파일이더라도 실행할 때마다 내용이 달라집니다.  |
|  |  | 동적 내용은 해당 프로세스마다 다르므로 프로세스가 실행되는 동안 검사가 이루어 져야합니다. |

### 4.3 정적 메모리 레이아웃 검사
- `size` 명령어 -> `size libmymath.so`
  
<img width="848" height="61" alt="image" src="https://github.com/user-attachments/assets/a5d7b6a6-4fe3-47b8-b210-d3b19b0032e2" />

<img width="840" height="112" alt="image" src="https://github.com/user-attachments/assets/ee96b328-430e-43f6-8b4e-b9abe7b09733" />

---

- 아래 data와 bss 증가 확인을 목표로 진행해보자

```c
void main(){

	return;
}
```

mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ gcc ./hello.c 
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ size a.out 
   text    data     bss     dec     hex filename
   1224     544       8    1776     6f0 a.out
   
```c
int g_data[2];
void main(){

	return;
}
```

mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ gcc ./hello.c 
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ size a.out 
   text    data     bss     dec     hex filename
   1224     544      16    1784     6f8 a.out
   
```c
int g_data_init[2];
int g_data[2];
void main(){

	return;
}
```

mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ gcc ./hello.c 
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ size a.out 
   text    data     bss     dec     hex filename
   1224     544      24    1792     700 a.out
   
```c
int g_data_init[2];
int g_data[2];
void main(){
	static int data=10;
	return;
}
```

mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ gcc ./hello.c 
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ size a.out 
   text    data     bss     dec     hex filename
   1224     548      24    1796     704 a.out

---

- 전역 변수 데이터를 작성하면 bss가 증가함을 확인할 수 있고,
- 코드 영역의 지역 변수를 작성하면 data가 증가하는 것을 확인할 수 있다.

- hello.s <-> ~hello.s
  `gcc -S hello.c` 명령어를 통해 어셈블러 생성

- `size` 명령어 → 실행 가능한 목적 파일의 정적 메모리 레이아웃을 출력할 때 사용

<img width="1102" height="687" alt="image" src="https://github.com/user-attachments/assets/ee96e075-55af-4375-93a7-91d1b38a8487" />

**4.3, 4.4가 핵심적인 부분**

### 4.4 동적 메모리 레이아웃 검사하기
- 동적 메모리 레이아웃 : 프로세스의 런타임 메모리(runtime memory), 프로세스가 실행되는 동안 존재
- 실행중인 프로세스의 메모리 레이아웃에는 5개의 세그먼트가 존재
- 동적 메모리 할당 ->

### 4.4.1 메모리 매핑
- 프로그램 돌아가는 동안 체킹 가능 프로그램 끝나면 확인 불가
- while(1)문으로 무한실행되는 프로세스에서 메모리 구조를 검사 가능

예제 4.4.1)

```c
#include <unistd.h> // 윈도우처럼 POSIX 규격이 아닌 경우에는 windows.h를 대신 포함해야 함

int main(int argc, char** argv) {
  // Infinite loop
  while (1) {
    sleep(1); // Sleep 1 second
  };
  return 0;
}
```

```
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ ./a.out &
[1] 57336
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ ps
    PID TTY          TIME CMD
  40047 pts/5    00:00:00 bash
  57336 pts/5    00:00:00 a.out
  57349 pts/5    00:00:00 ps
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ ls -l /proc/57336
total 0
-r--r--r--  1 mo mo 0 Jan  9 16:12 arch_status
dr-xr-xr-x  2 mo mo 0 Jan  9 16:12 attr
-r--------  1 mo mo 0 Jan  9 16:12 auxv
-r--r--r--  1 mo mo 0 Jan  9 16:12 cgroup
--w-------  1 mo mo 0 Jan  9 16:12 clear_refs
-r--r--r--  1 mo mo 0 Jan  9 16:11 cmdline
-rw-r--r--  1 mo mo 0 Jan  9 16:12 comm
-rw-r--r--  1 mo mo 0 Jan  9 16:12 coredump_filter
-r--r--r--  1 mo mo 0 Jan  9 16:12 cpuset
lrwxrwxrwx  1 mo mo 0 Jan  9 16:11 cwd -> /home/mo/Intel_AI_SW_Academy_9th/Linux/project
-r--------  1 mo mo 0 Jan  9 16:11 environ
lrwxrwxrwx  1 mo mo 0 Jan  9 16:12 exe -> /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
dr-x------  2 mo mo 3 Jan  9 16:11 fd
dr-xr-xr-x  2 mo mo 0 Jan  9 16:12 fdinfo
-rw-r--r--  1 mo mo 0 Jan  9 16:12 gid_map
-r--------  1 mo mo 0 Jan  9 16:12 io
-r--------  1 mo mo 0 Jan  9 16:12 ksm_merging_pages
-r--------  1 mo mo 0 Jan  9 16:12 ksm_stat
-r--r--r--  1 mo mo 0 Jan  9 16:12 latency
-r--r--r--  1 mo mo 0 Jan  9 16:12 limits
-rw-r--r--  1 mo mo 0 Jan  9 16:12 loginuid
dr-x------  2 mo mo 0 Jan  9 16:12 map_files
-r--r--r--  1 mo mo 0 Jan  9 16:12 maps
-rw-------  1 mo mo 0 Jan  9 16:12 mem
-r--r--r--  1 mo mo 0 Jan  9 16:12 mountinfo
-r--r--r--  1 mo mo 0 Jan  9 16:12 mounts
-r--------  1 mo mo 0 Jan  9 16:12 mountstats
dr-xr-xr-x 57 mo mo 0 Jan  9 16:12 net
dr-x--x--x  2 mo mo 0 Jan  9 16:12 ns
-r--r--r--  1 mo mo 0 Jan  9 16:12 numa_maps
-rw-r--r--  1 mo mo 0 Jan  9 16:12 oom_adj
-r--r--r--  1 mo mo 0 Jan  9 16:12 oom_score
-rw-r--r--  1 mo mo 0 Jan  9 16:12 oom_score_adj
-r--------  1 mo mo 0 Jan  9 16:12 pagemap
-r--------  1 mo mo 0 Jan  9 16:12 patch_state
-r--------  1 mo mo 0 Jan  9 16:12 personality
-rw-r--r--  1 mo mo 0 Jan  9 16:12 projid_map
lrwxrwxrwx  1 mo mo 0 Jan  9 16:12 root -> /
-rw-r--r--  1 mo mo 0 Jan  9 16:12 sched
-r--r--r--  1 mo mo 0 Jan  9 16:12 schedstat
-r--r--r--  1 mo mo 0 Jan  9 16:12 sessionid
-rw-r--r--  1 mo mo 0 Jan  9 16:12 setgroups
-r--r--r--  1 mo mo 0 Jan  9 16:12 smaps
-r--r--r--  1 mo mo 0 Jan  9 16:12 smaps_rollup
-r--------  1 mo mo 0 Jan  9 16:12 stack
-r--r--r--  1 mo mo 0 Jan  9 16:11 stat
-r--r--r--  1 mo mo 0 Jan  9 16:12 statm
-r--r--r--  1 mo mo 0 Jan  9 16:11 status
-r--------  1 mo mo 0 Jan  9 16:12 syscall
dr-xr-xr-x  3 mo mo 0 Jan  9 16:12 task
-rw-r--r--  1 mo mo 0 Jan  9 16:12 timens_offsets
-r--r--r--  1 mo mo 0 Jan  9 16:12 timers
-rw-rw-rw-  1 mo mo 0 Jan  9 16:12 timerslack_ns
-rw-r--r--  1 mo mo 0 Jan  9 16:12 uid_map
-r--r--r--  1 mo mo 0 Jan  9 16:11 wchan
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$
```

- 운영체제에서 프로세스를 관리하고 있다.
- `/proc/57336` 에 파일이 생성된걸 확인할 수 있다.

```
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ cat /proc/57336/maps
618793ce2000-618793ce3000 r--p 00000000 08:30 71396                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
618793ce3000-618793ce4000 r-xp 00001000 08:30 71396                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
618793ce4000-618793ce5000 r--p 00002000 08:30 71396                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
618793ce5000-618793ce6000 r--p 00002000 08:30 71396                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
618793ce6000-618793ce7000 rw-p 00003000 08:30 71396                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
789d0a400000-789d0a428000 r--p 00000000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
789d0a428000-789d0a5b0000 r-xp 00028000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
789d0a5b0000-789d0a5ff000 r--p 001b0000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
789d0a5ff000-789d0a603000 r--p 001fe000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
789d0a603000-789d0a605000 rw-p 00202000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
789d0a605000-789d0a612000 rw-p 00000000 00:00 0
789d0a61f000-789d0a622000 rw-p 00000000 00:00 0
789d0a62b000-789d0a62d000 rw-p 00000000 00:00 0
789d0a62d000-789d0a62e000 r--p 00000000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
789d0a62e000-789d0a659000 r-xp 00001000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
789d0a659000-789d0a663000 r--p 0002c000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
789d0a663000-789d0a665000 r--p 00036000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
789d0a665000-789d0a667000 rw-p 00038000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffd40aa1000-7ffd40ac2000 rw-p 00000000 00:00 0                          [stack]
7ffd40b8c000-7ffd40b90000 r--p 00000000 00:00 0                          [vvar]
7ffd40b90000-7ffd40b92000 r-xp 00000000 00:00 0                          [vdso]
```

- 7ffd40aa1000-7ffd40ac2000 rw-p 00000000 00:00 0                          [stack] -> 현재 실시간으로 스택 영역의 메모리 구조 확인 가능

`r--p` : read만 할 수 있는 영역
`r-xp` : read, x:실행 까지 가능
`rw-p` : read, write 까지 가능

- 메모리 구조 말고 메모리 안의 내용을 확인하려면? -> gdb 사용 57336


```
mo@DESKTOP-HMRIDMH:~/Intel_AI_SW_Academy_9th/Linux/project$ cd /proc/
mo@DESKTOP-HMRIDMH:/proc$ ls
1      2    40040  47813  526    acpi       devices        interrupts  kpagecgroup    mounts        self           timer_list
105    202  40041  47883  543    buddyinfo  diskstats      iomem       kpagecount     mpt           slabinfo       tty
106    217  40047  481    57336  bus        dma            ioports     kpageflags     mtrr          softirqs       uptime
159    219  416    492    58661  cgroups    driver         irq         latency_stats  net           stat           version
160    225  468    493    59338  cmdline    dynamic_debug  kallsyms    loadavg        pagetypeinfo  swaps          vmallocinfo
16406  350  469    494    59519  config.gz  execdomains    kcore       locks          partitions    sys            vmstat
16420  391  470    501    610    consoles   fb             key-users   meminfo        pressure      sysrq-trigger  zoneinfo
177    392  471    502    7      cpuinfo    filesystems    keys        misc           schedstat     sysvipc
1873   40   477    503    86     crypto     fs             kmsg        modules        scsi          thread-self
mo@DESKTOP-HMRIDMH:/proc$ kill 57336
mo@DESKTOP-HMRIDMH:/proc$ ls
1      2    40040  47813  526    buddyinfo  diskstats      iomem        kpagecount     mpt           slabinfo       tty
105    202  40041  47883  543    bus        dma            ioports      kpageflags     mtrr          softirqs       uptime
106    217  40047  481    58661  cgroups    driver         irq          latency_stats  net           stat           version
159    219  416    492    59338  cmdline    dynamic_debug  kallsyms     loadavg        pagetypeinfo  swaps          vmallocinfo
160    225  468    493    59604  config.gz  execdomains    kcore        locks          partitions    sys            vmstat
16406  350  469    494    610    consoles   fb             key-users    meminfo        pressure      sysrq-trigger  zoneinfo
16420  391  470    501    7      cpuinfo    filesystems    keys         misc           schedstat     sysvipc
177    392  471    502    86     crypto     fs             kmsg         modules        scsi          thread-self
1873   40   477    503    acpi   devices    interrupts     kpagecgroup  mounts         self          timer_list
[1]-  Terminated              ./a.out  (wd: ~/Intel_AI_SW_Academy_9th/Linux/project)
(wd now: /proc)

mo@DESKTOP-HMRIDMH:/proc$ ps
    PID TTY          TIME CMD
  40047 pts/5    00:00:00 bash
  59338 pts/5    00:00:00 gdb
  59696 pts/5    00:00:00 ps
```
  

<img width="898" height="356" alt="image" src="https://github.com/user-attachments/assets/b1caa3a0-ab6a-4678-b9c4-58010cce6d72" />

<img width="972" height="330" alt="image" src="https://github.com/user-attachments/assets/b2e07b0e-3af3-4b63-b11a-cafb7c53a97f" />

<img width="935" height="64" alt="image" src="https://github.com/user-attachments/assets/b5817cbf-53a0-43b4-bfc2-4c31a9d9ea34" />

<img width="935" height="64" alt="image" src="https://github.com/user-attachments/assets/6661c71b-13bd-4c6a-938f-a4035a7b31f7" />

gdb 노션에서 검색해서 메모리 확인법 실습해보기

<img width="791" height="469" alt="image" src="https://github.com/user-attachments/assets/ef3914f3-7025-4d8d-adf8-1a50f4ad22fc" />

---

### heap

```
mo@DESKTOP-HMRIDMH:/proc$ cat /proc/61928/maps
56042a67e000-56042a67f000 r--p 00000000 08:30 62904                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
56042a67f000-56042a680000 r-xp 00001000 08:30 62904                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
56042a680000-56042a681000 r--p 00002000 08:30 62904                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
56042a681000-56042a682000 r--p 00002000 08:30 62904                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
56042a682000-56042a683000 rw-p 00003000 08:30 62904                      /home/mo/Intel_AI_SW_Academy_9th/Linux/project/a.out
560441733000-560441754000 rw-p 00000000 00:00 0                          [heap]
78c806400000-78c806428000 r--p 00000000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
78c806428000-78c8065b0000 r-xp 00028000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
78c8065b0000-78c8065ff000 r--p 001b0000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
78c8065ff000-78c806603000 r--p 001fe000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
78c806603000-78c806605000 rw-p 00202000 08:30 38863                      /usr/lib/x86_64-linux-gnu/libc.so.6
78c806605000-78c806612000 rw-p 00000000 00:00 0
78c806789000-78c80678c000 rw-p 00000000 00:00 0
78c806795000-78c806797000 rw-p 00000000 00:00 0
78c806797000-78c806798000 r--p 00000000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
78c806798000-78c8067c3000 r-xp 00001000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
78c8067c3000-78c8067cd000 r--p 0002c000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
78c8067cd000-78c8067cf000 r--p 00036000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
78c8067cf000-78c8067d1000 rw-p 00038000 08:30 38814                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffd678ab000-7ffd678cc000 rw-p 00000000 00:00 0                          [stack]
7ffd67942000-7ffd67946000 r--p 00000000 00:00 0                          [vvar]
7ffd67946000-7ffd67948000 r-xp 00000000 00:00 0                          [vdso]
```

<img width="928" height="320" alt="image" src="https://github.com/user-attachments/assets/8c7cc30b-37ba-4fe0-8736-227204bce43b" />

<img width="612" height="51" alt="image" src="https://github.com/user-attachments/assets/ff6082ed-f70e-4c05-98dd-55d1810cd57e" />

<img width="962" height="129" alt="image" src="https://github.com/user-attachments/assets/3f7c154e-b0a7-4f27-970c-92c61ced833d" />

- 프로세스 실행중일때 -> gdb 이용해서 확인 -> gdb 종료해야 기존 프로세스 빌드 가능
- malloc 할당해주고, 주소 범위 확인해보면 늘어있을 것?
- heap 영역에서 포인터를 확인해야함..
- gdb -> `p *ptr` ? / `b` : breaking point 잡기 / `n` : next

  <img width="894" height="425" alt="image" src="https://github.com/user-attachments/assets/99221856-06e5-4715-a9f4-96e893e0560b" />


  <img width="684" height="321" alt="image" src="https://github.com/user-attachments/assets/624b788e-1c57-4315-9b19-2af9ec63c762" />
