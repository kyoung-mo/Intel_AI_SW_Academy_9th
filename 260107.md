리눅스 시스템 프로그래밍과 C언어에서 **함수 포인터(Function Pointer)**는 단순한 기능을 넘어 **유연한 아키텍처, 추상화, 모듈화**를 구현하는 핵심 도구입니다.

리눅스 환경에서 자주 사용되는 주요 사례 5가지를 정리해 드립니다.

---

### 1. 콜백 함수 (Callback Mechanism)

가장 흔한 사용 사례입니다. 특정 이벤트가 발생하거나 작업이 완료되었을 때 호출될 함수를 인자로 전달합니다.

- **사용 이유:** 라이브러리 작성자가 사용자가 정의한 로직을 수행할 수 있도록 "구멍"을 열어두기 위함입니다.
- **대표 사례:** `qsort` (정렬), `pthread_create` (스레드 실행), `signal` (시그널 핸들링).

**예시 코드 (`qsort` 활용):**

callback.c

```c
#include <stdio.h>
#include <stdlib.h>

// 비교 로직을 함수 포인터로 전달
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int arr[] = {5, 2, 9, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    // qsort의 4번째 인자가 함수 포인터입니다.
    qsort(arr, n, sizeof(int), compare); 

    for(int i=0; i<n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---

### 2. 구조체를 이용한 객체지향(OOP) 흉내내기 (Polymorphism)

C언어에는 클래스가 없지만, 구조체 안에 함수 포인터를 넣어 **메서드(Method)처럼 사용**할 수 있습니다. 이를 통해 다형성(Polymorphism)을 구현합니다.

- **리눅스 커널 사례:** 리눅스 커널의 **VFS(가상 파일 시스템)**이 이 방식을 완벽하게 보여줍니다. `file_operations` 구조체는 `read`, `write`, `open` 등의 함수 포인터를 가지고 있으며, 디바이스 드라이버마다 실제 동작 함수를 다르게 연결합니다.

**예시 코드 (가상 인터페이스 구현):**

like_oop.c

```c
#include <stdio.h>

typedef struct {
    const char *name;
    void (*speak)(void); // 함수 포인터: 동작 정의
} Animal;

void dog_speak() { printf("멍멍\n"); }
void cat_speak() { printf("야옹\n"); }

int main() {
    // 같은 구조체지만 다른 동작을 연결
    Animal dog = {"강아지", dog_speak};
    Animal cat = {"고양이", cat_speak};

    dog.speak(); // 멍멍
    cat.speak(); // 야옹
    return 0;
}
```

---

### 3. 상태 머신 및 점프 테이블 (Jump Table)

복잡하고 긴 `if-else` 문이나 `switch-case` 문을 대체하여 성능을 높이고 코드를 간결하게 만듭니다. 함수 포인터 배열을 사용합니다.

- **사용 이유:** O(1)의 속도로 조건에 맞는 함수를 실행할 수 있습니다. 통신 프로토콜 파서나 명령어 처리기에서 많이 쓰입니다.

**예시 코드 (명령어 처리기):**

jump_table.c

```c
#include <stdio.h>

void cmd_start() { printf("System Starting...\n"); }
void cmd_stop()  { printf("System Stopping...\n"); }
void cmd_reset() { printf("System Reset...\n"); }

int main() {
    // 함수 포인터 배열 (Look-up Table)
    void (*cmd_actions[])(void) = {cmd_start, cmd_stop, cmd_reset};
    
    int opcode = 1; // 0: start, 1: stop, 2: reset
    
    // switch문 없이 배열 인덱스로 바로 실행
    if(opcode >= 0 && opcode <= 2) {
        cmd_actions[opcode](); 
    }
    return 0;
}
```

---

### 4. 동적 라이브러리 로딩 (Plugin Architecture)

프로그램 실행 중에 외부 라이브러리(.so 파일)를 로드하고 그 안의 함수를 실행할 때 사용합니다.

- **관련 함수:** `dlopen`, `dlsym`, `dlclose`
- **활용:** 플러그인 시스템을 만들 때 필수적입니다. 메인 프로그램은 컴파일 시점에 플러그인의 존재를 몰라도 됩니다.

**예시 코드 (개념):**

plugin.c

```c
#include <dlfcn.h>

int main() {
    void *handle = dlopen("./libplugin.so", RTLD_LAZY);
    
    // 심볼(함수 이름)로 함수 포인터 획득
    void (*plugin_func)() = dlsym(handle, "do_something");
    
    if (plugin_func) {
        plugin_func(); // 동적으로 불러온 함수 실행
    }
    
    dlclose(handle);
    return 0;
}
```

---

### 5. 인터럽트 및 시그널 핸들러 (System Level)

리눅스 시스템 프로그래밍 레벨에서, 특정 하드웨어 인터럽트나 OS 시그널이 발생했을 때 제어권을 넘겨받을 함수를 등록합니다.

- **대표 사례:** `signal()` 함수나 `sigaction` 구조체.
- **주의점:** 핸들러 함수 내부에서는 비동기적으로 안전한(Async-signal-safe) 함수만 사용해야 하는 제약이 있습니다.

signal.c

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 시그널이 발생하면 호출될 함수 포인터 타겟
void handle_sigint(int sig) {
    printf("\nCaught signal %d (Ctrl+C)\n", sig);
}

int main() {
    // 함수 포인터를 등록
    signal(SIGINT, handle_sigint); 
    
    while(1) {
        printf("Running... (Press Ctrl+C)\n");
        sleep(1);
    }
    return 0;
}
```

---

### 

| **사용 사례** | **핵심 목적** | **대표 키워드/함수** |
| --- | --- | --- |
| **콜백** | 실행 흐름의 제어권 위임 | `qsort`, `pthread_create` |
| **다형성** | 구조체로 객체지향 흉내내기 | `file_operations` (커널), 드라이버 |
| **점프 테이블** | `switch`문 대체, 성능 최적화 | 배열(`[]`), 상태 머신 |
| **동적 로딩** | 런타임 플러그인 확장 | `dlopen`, `dlsym` |
| **핸들러** | 비동기 이벤트 처리 | `signal`, ISR |
